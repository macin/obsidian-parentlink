/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ParentLink
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enabled: true,
  detailedLogs: false,
  allowedPaths: []
  // Default to empty array (all paths allowed)
};
var ParentLink = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvents();
    this.addSettingTab(new ParentLinkSettingTab(this.app, this));
  }
  registerEvents() {
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (file instanceof import_obsidian.TFile && this.settings.enabled) {
          await this.updateParentLink(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        var _a, _b;
        if (!this.settings.enabled)
          return;
        if (file instanceof import_obsidian.TFile) {
          await this.updateParentLink(file);
          const isFolderNote = file.basename === ((_a = file.parent) == null ? void 0 : _a.name);
          if (isFolderNote) {
            if (this.settings.detailedLogs) {
              console.log(`Folder note renamed, updating child notes in ${(_b = file.parent) == null ? void 0 : _b.path}`);
            }
            const childFiles = this.app.vault.getMarkdownFiles().filter((f) => {
              var _a2, _b2;
              return ((_a2 = f.parent) == null ? void 0 : _a2.path) === ((_b2 = file.parent) == null ? void 0 : _b2.path) && f !== file;
            });
            for (const childFile of childFiles) {
              if (this.settings.detailedLogs) {
                console.log(`Updating child note: ${childFile.path}`);
              }
              await this.updateParentLink(childFile);
            }
          }
        } else if (file instanceof import_obsidian.TFolder) {
          await this.handleFolderRename(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        var _a;
        if (!this.settings.enabled || !(file instanceof import_obsidian.TFile))
          return;
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = cache == null ? void 0 : cache.frontmatter;
        const isFolderNote = file.basename === ((_a = file.parent) == null ? void 0 : _a.name);
        if (isFolderNote && (!(frontmatter == null ? void 0 : frontmatter.parent) || frontmatter.parent === "") && file.parent) {
          if (this.settings.detailedLogs) {
            console.log(`Folder note modified externally: ${file.path}, updating children`);
          }
          await this.handleFolderRename(file.parent);
        }
      })
    );
  }
  async processAllFiles() {
    if (this.settings.detailedLogs) {
      console.log("Starting to process all files...");
      const files2 = this.app.vault.getMarkdownFiles();
      console.log(`Found ${files2.length} markdown files`);
    }
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.settings.detailedLogs) {
        console.log(`Processing file: ${file.path}`);
      }
      await this.updateParentLink(file);
    }
    new import_obsidian.Notice("ParentLink: Finished processing all files");
  }
  async updateParentLink(file) {
    var _a, _b;
    try {
      if (this.settings.allowedPaths.length > 0) {
        const isAllowed = this.settings.allowedPaths.some(
          (allowedPath) => {
            var _a2;
            return file.path.startsWith(allowedPath) || // Also check parent folder for folder notes
            (((_a2 = file.parent) == null ? void 0 : _a2.path) || "").startsWith(allowedPath);
          }
        );
        if (!isAllowed) {
          if (this.settings.detailedLogs) {
            console.log(`${file.path} - skipped (not in allowed paths)`);
          }
          return;
        }
      }
      const parentFolder = file.parent;
      if (!parentFolder) {
        if (this.settings.detailedLogs) {
          console.log(`${file.path} - skipped (no parent folder)`);
        }
        return;
      }
      let parentNote = null;
      const isFolderNote = file.basename === parentFolder.name;
      if (file.basename.toLowerCase() === parentFolder.name.toLowerCase() && !isFolderNote) {
        if (this.settings.detailedLogs) {
          console.log(`${file.path} - skipped (folder note name case doesn't match folder name)`);
        }
        return;
      }
      if (isFolderNote) {
        const grandparentFolder = parentFolder.parent;
        if (grandparentFolder) {
          parentNote = this.app.vault.getMarkdownFiles().find(
            (f) => {
              var _a2;
              return f.basename === grandparentFolder.name && ((_a2 = f.parent) == null ? void 0 : _a2.path) === grandparentFolder.path && f !== file;
            }
          ) || null;
        }
      } else {
        parentNote = this.app.vault.getMarkdownFiles().find(
          (f) => {
            var _a2;
            return f.basename === parentFolder.name && ((_a2 = f.parent) == null ? void 0 : _a2.path) === parentFolder.path && f !== file;
          }
        ) || null;
      }
      if (!parentNote) {
        const targetFolder = isFolderNote ? (_a = parentFolder.parent) == null ? void 0 : _a.name : parentFolder.name;
        if (this.settings.detailedLogs) {
          console.log(`${file.path} - skipped (no matching parent note for folder ${targetFolder})`);
        }
        return;
      }
      const cache = this.app.metadataCache.getFileCache(file);
      const currentParent = (_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b.parent;
      const newParent = "[[" + parentNote.name.replace(".md", "") + "]]";
      if (currentParent !== newParent) {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          frontmatter.parent = newParent;
          if (this.settings.detailedLogs) {
            console.log(`${file.path} - frontmatter updated with parent: ${newParent}`);
          }
        });
      } else if (this.settings.detailedLogs) {
        console.log(`${file.path} - skipped (parent already set correctly)`);
      }
    } catch (error) {
      console.error(`${file.path} - error updating parent link:`, error);
      new import_obsidian.Notice(`Error updating parent link for ${file.path}`);
    }
  }
  onunload() {
    if (this.settings.detailedLogs) {
      console.log("unloading plugin");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async handleFolderRename(folder) {
    if (this.settings.detailedLogs) {
      console.log(`Folder renamed/modified: ${folder.path}, updating all files inside`);
    }
    const filesInFolder = this.app.vault.getMarkdownFiles().filter((f) => {
      if (folder.isRoot()) {
        return true;
      }
      return f.path.startsWith(folder.path + "/");
    });
    for (const childFile of filesInFolder) {
      await this.updateParentLink(childFile);
    }
    if (!folder.isRoot()) {
      const folderNote = this.app.vault.getMarkdownFiles().find((f) => {
        var _a;
        return f.basename === folder.name && ((_a = f.parent) == null ? void 0 : _a.path) === folder.path;
      });
      if (folderNote) {
        if (this.settings.detailedLogs) {
          console.log(`Updating folder note: ${folderNote.path}`);
        }
        await this.updateParentLink(folderNote);
      }
    }
  }
};
var ParentLinkSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Parent Link Settings" });
    this.addBasicSettings(containerEl);
    this.addFolderRefreshSetting(containerEl);
    containerEl.createEl("h3", { text: "Allowed Paths" });
    containerEl.createEl("p", {
      text: "Specify paths where the plugin should work. Leave empty to allow all paths.",
      cls: "setting-item-description"
    });
    this.allowedPathsContainer = containerEl.createDiv({ cls: "parent-link-allowed-paths" });
    const addButton = new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Add Path").setClass("mod-setting-button").onClick(() => {
      this.addAllowedPathInput();
    }));
    if (this.plugin.settings.allowedPaths.length === 0) {
      this.addAllowedPathInput();
    } else {
      this.plugin.settings.allowedPaths.forEach((path) => {
        this.addAllowedPathInput(path);
      });
    }
    containerEl.createEl("style", {
      text: `
        .parent-link-input-container {
          position: relative;
          flex: 1;
        }
        .parent-link-input-container input {
          width: 100%;
          padding: 6px 12px;
          height: var(--input-height);
          background: var(--background-modifier-form-field);
          border: var(--input-border-width) solid var(--background-modifier-border);
          color: var(--text-normal);
          border-radius: var(--radius-s);
          font-size: var(--font-ui-small);
        }
        .parent-link-suggestion-container {
          position: absolute;
          width: 100%;
          max-height: 200px;
          overflow-y: auto;
          background: var(--background-primary);
          border: 1px solid var(--background-modifier-border);
          z-index: 100;
          border-radius: var(--radius-s);
          box-shadow: var(--shadow-s);
          margin-top: 4px;
        }
        .parent-link-suggestion {
          padding: 8px 12px;
          cursor: pointer;
          font-size: var(--font-ui-small);
        }
        .parent-link-suggestion:hover,
        .parent-link-suggestion.is-selected {
          background: var(--background-modifier-hover);
          color: var(--text-accent);
        }
        .parent-link-allowed-path {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 8px;
          width: 100%;
          padding: 0 20px;
        }
        .parent-link-remove-button {
          padding: 0;
          background: var(--background-modifier-error);
          border: none;
          color: var(--text-on-accent);
          border-radius: var(--radius-s);
          cursor: pointer;
          height: var(--input-height);
          width: var(--input-height);
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 18px;
        }
        .parent-link-remove-button:hover {
          background: var(--background-modifier-error-hover);
        }
        .parent-link-allowed-paths {
          width: 100%;
          margin-bottom: 12px;
        }
        .setting-item.mod-setting-button {
          padding-left: 20px;
          padding-right: 20px;
        }
      `
    });
  }
  addBasicSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Enable automatic parent linking").setDesc("Automatically add parent links to files when they are created or moved").addToggle((toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
      this.plugin.settings.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable detailed logs").setDesc("Show additional processing details in the console").addToggle((toggle) => toggle.setValue(this.plugin.settings.detailedLogs).onChange(async (value) => {
      this.plugin.settings.detailedLogs = value;
      await this.plugin.saveSettings();
    }));
  }
  addAllowedPathInput(initialValue = "") {
    const container = this.allowedPathsContainer.createDiv({ cls: "parent-link-allowed-path" });
    const inputContainer = container.createDiv({ cls: "parent-link-input-container" });
    const input = inputContainer.createEl("input", {
      type: "text",
      value: initialValue,
      placeholder: "Type folder path..."
    });
    const suggestionContainer = inputContainer.createDiv({
      cls: "parent-link-suggestion-container"
    });
    suggestionContainer.style.display = "none";
    const removeButton = container.createEl("button", {
      text: "\xD7",
      title: "Remove path",
      cls: "parent-link-remove-button"
    });
    removeButton.onclick = () => {
      container.remove();
      this.saveAllowedPaths();
    };
    let selectedIndex = -1;
    const handleKeydown = (event) => {
      const suggestions = suggestionContainer.children;
      if (suggestions.length === 0)
        return;
      if (event.key === "ArrowDown" || event.key === "ArrowUp") {
        event.preventDefault();
        if (event.key === "ArrowDown") {
          selectedIndex = (selectedIndex + 1) % suggestions.length;
        } else {
          selectedIndex = selectedIndex <= 0 ? suggestions.length - 1 : selectedIndex - 1;
        }
        Array.from(suggestions).forEach((el, i) => {
          el.classList.toggle("is-selected", i === selectedIndex);
        });
      } else if (event.key === "Enter" && selectedIndex >= 0) {
        event.preventDefault();
        const selectedSuggestion = suggestions[selectedIndex];
        input.value = selectedSuggestion.textContent || "";
        suggestionContainer.style.display = "none";
        selectedIndex = -1;
        this.saveAllowedPaths();
      } else if (event.key === "Escape") {
        suggestionContainer.style.display = "none";
        selectedIndex = -1;
      }
    };
    input.addEventListener("input", () => {
      selectedIndex = -1;
      this.updatePathSuggestions(input, suggestionContainer);
      this.saveAllowedPaths();
    });
    input.addEventListener("focus", () => {
      this.updatePathSuggestions(input, suggestionContainer);
    });
    input.addEventListener("blur", () => {
      setTimeout(() => {
        suggestionContainer.style.display = "none";
        selectedIndex = -1;
      }, 200);
    });
    input.addEventListener("keydown", handleKeydown);
  }
  updatePathSuggestions(input, suggestionContainer) {
    const inputValue = input.value.toLowerCase();
    const folders = this.getAllFolders();
    const suggestions = folders.filter(
      (f) => f.path.toLowerCase().contains(inputValue)
    );
    suggestionContainer.empty();
    if (suggestions.length > 0 && inputValue) {
      suggestionContainer.style.display = "block";
      suggestions.forEach((folder) => {
        const suggestionEl = suggestionContainer.createDiv({
          cls: "parent-link-suggestion",
          text: folder.path
        });
        suggestionEl.onmousedown = () => {
          input.value = folder.path;
          suggestionContainer.style.display = "none";
          this.saveAllowedPaths();
        };
      });
    } else {
      suggestionContainer.style.display = "none";
    }
  }
  saveAllowedPaths() {
    const inputs = this.allowedPathsContainer.querySelectorAll("input");
    const paths = Array.from(inputs).map((input) => input.value.trim()).filter((path) => path.length > 0);
    this.plugin.settings.allowedPaths = paths;
    this.plugin.saveSettings();
  }
  getAllFolders() {
    const folders = [];
    const files = this.app.vault.getAllLoadedFiles();
    files.forEach((file) => {
      if (file instanceof import_obsidian.TFolder) {
        folders.push(file);
      }
    });
    return folders;
  }
  addFolderRefreshSetting(containerEl) {
    const folderSetting = new import_obsidian.Setting(containerEl).setName("Refresh folder parents").setDesc("Type folder path to refresh parent links for all files in that folder");
    const inputContainer = containerEl.createDiv({ cls: "parent-link-input-container" });
    this.folderInputEl = inputContainer.createEl("input", {
      type: "text",
      value: this.plugin.settings.lastRefreshedFolder || "",
      placeholder: "Type folder path..."
    });
    this.suggestionContainer = inputContainer.createDiv({
      cls: "parent-link-suggestion-container"
    });
    this.suggestionContainer.style.display = "none";
    folderSetting.addButton((button) => button.setButtonText("Refresh").onClick(async () => {
      const folderPath = this.folderInputEl.value;
      if (folderPath === "/" || folderPath === "") {
        const rootFolder = this.app.vault.getRoot();
        this.plugin.settings.lastRefreshedFolder = "/";
        await this.plugin.saveSettings();
        await this.plugin.handleFolderRename(rootFolder);
        new import_obsidian.Notice(`Updated parent links in the entire vault`);
      } else {
        const folder = this.app.vault.getAbstractFileByPath(folderPath);
        if (folder instanceof import_obsidian.TFolder) {
          this.plugin.settings.lastRefreshedFolder = folderPath;
          await this.plugin.saveSettings();
          await this.plugin.handleFolderRename(folder);
          new import_obsidian.Notice(`Updated parent links in ${folderPath}`);
        } else {
          new import_obsidian.Notice("Please enter a valid folder path");
        }
      }
    }));
    this.folderInputEl.addEventListener("input", () => {
      this.updatePathSuggestions(this.folderInputEl, this.suggestionContainer);
    });
    this.folderInputEl.addEventListener("focus", () => {
      this.updatePathSuggestions(this.folderInputEl, this.suggestionContainer);
    });
    this.folderInputEl.addEventListener("blur", () => {
      setTimeout(() => {
        this.suggestionContainer.style.display = "none";
      }, 200);
    });
  }
};
